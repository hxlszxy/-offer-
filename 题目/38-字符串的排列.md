# 38-字符串的排列

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

## 题目分析

- 排列问题

- 递归分解

  对于第一个字符来说，可以对第一个字符不变，后面的字符进行排列组合，或者后面的字符相对位置不变，第一个字符随机从后面抽取一个字符作为第一个字符。这两种情况的总和就是这个字符串的前排列。

  而对于第一个字符不变，后面的字符进行排列组合的问题，可以继续分解为上述的排列过程。

  因此这整个过程是一个分为两个阶段的递归过程

  - 不固定第一个字符，后续序列固定，从后续序列抽取一个元素和第一个字符交换
  - 固定第一个字符，后续序列再排列
  
- 字符串中有重复的情况

  - 求全排列之前进行排序
  - 如果以某字符为第一个字符时发现之前的字符等于此字符，说明已经得到了全排列，则不再进行排列



## 代码实现

```python
#实现思路1
#对字符串排序
#对排序后的字符串表中
#首先确定一个字符为首字符
#然后对其余的其他字符求全排列
#得到以该字符串为首的全排列
#实现时注意，因为是字符串中某一字符为首，求其余全排列，因此切分时只需要去除该字符串即可
class Solution:
    def Permutation(self, ss):
        if not ss:
            return []
        if len(ss) ==1:
            return list(ss)
        pStr = []
        charlist = list(ss)
        charlist.sort() 
        #因为这里取的是整个字符串的排列
        #下面是每次假设第一个字符为其子排列的第一个字符，然后对后面的字符再求全排列
        for i in range(len(charlist)):
            #如果此字符和前一个字符相等，则其得到的全排列一样
            if i>0 and charlist[i] == charlist[i-1]:
                continue
            #这里是求去除i以后的字符串的排列
            #这里只需要传入除了该字符的其他字符就可以
            temp=self.Permutation(''.join(charlist[:i])+''.join(charlist[i+1:]))
            #得到此子序列除了该字符之外的全排列，将其余的字符与此字符作为组合加入结果
            for j in temp:
                pStr.append(charlist[i]+j)
        return pStr
if __name__ == "__main__":
    a = Solution().Permutation("abc")
    print(a)
```



